# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eZafQInmnm83JT75P8JxfpPb8ijcZ9AL
"""

# Commented out IPython magic to ensure Python compatibility.

# %cd Vertical-Bracing-UFM
# %pip install -e .

from steelpy import aisc
import forallpeople as si
si.environment('structural', top_level=False)
from typing import Any, Type
import math
from steel_lib.data_models import Plate, BoltConfiguration, SteelpyMemberFactory
from steel_lib.materials import MATERIALS, BOLT_GRADES
from steel_lib.calculations import (
    BoltShearCalculator,
    check_dcr,
    BlockShearCalculator,
    ConnectionCapacityCalculator,
    TensileYieldingCalculator,
    TensileRuptureCalculator,
)
from dataclasses import dataclass, field

import math
from typing import Union

# Define a type hint for numbers for clarity
Numeric = Union[int, float]

def round_to_interval(number: Numeric, interval: Numeric) -> Numeric:
    """
    Rounds a number to the nearest specified interval.

    Args:
        number: The number to round.
        interval: The interval to round to (e.g., 5, 0.5, 10).

    Returns:
        The number rounded to the nearest interval.
    """
    if interval == 0:
        raise ValueError("Interval cannot be zero.")

    return round(number / interval) * interval

def round_up_to_interval(number: Numeric, interval: Numeric) -> Numeric:
    """
    Rounds a number UP to the nearest specified interval (ceiling).

    This function always rounds to the interval that is greater than or
    equal to the original number.

    Args:
        number: The number to round.
        interval: The interval to round up to (e.g., 5, 0.5, 10).

    Returns:
        The number rounded up to the nearest interval.
    """
    if interval == 0:
        raise ValueError("Interval cannot be zero.")

    # 1. Divide the number by the interval.
    # 2. Use math.ceil() to always round the result up to the next whole number.
    # 3. Multiply back by the interval to get the final value.
    return math.ceil(number / interval) * interval

gusset_plate = Plate.create_plate_member(
        t=1 ,
        material=MATERIALS["a572_gr50"]
    )

selected_bolt_grade = BOLT_GRADES["a325_x"]
gusset_connection = BoltConfiguration(
        row_spacing=3.0 * si.inch,
        column_spacing=3.0 * si.inch,
        n_rows=2,
        n_columns=7,
        edge_distance_vertical=2 * si.inch,
        edge_distance_horizontal=1.5 * si.inch,
        bolt_diameter=7/8 * si.inch,
        bolt_grade=selected_bolt_grade, # Assign the object directly
        material=MATERIALS["a572_gr50"]
    )
gusset_connection.connection_type = "bracing"
gusset_connection.angle = 47.2 * math.pi/180



gusset_plate = Plate.create_plate_member(
        t=1 ,
        material=MATERIALS["a572_gr50"]
    )
end_pl_column = Plate.create_plate_member(
        t=1 ,
        material=MATERIALS["a572_gr50"]
    )

selected_bolt_grade = BOLT_GRADES["a325_x"]
gusset_column_endpl_connection = BoltConfiguration(
        row_spacing=3.0 * si.inch,
        column_spacing=3.0 * si.inch,
        n_rows=7,
        n_columns=2,
        edge_distance_vertical=3 * si.inch,
        edge_distance_horizontal=1.5 * si.inch,
        bolt_diameter=7/8 * si.inch,
        bolt_grade=selected_bolt_grade, # Assign the object directly
        material=MATERIALS["a572_gr50"]
    )
gusset_column_endpl_connection.connection_type = "bracing"
gusset_column_endpl_connection.angle = 47.2 * math.pi/180

class TensileYieldWhitmore:
    """
    Calculates the tensile yielding capacity based on the Whitmore section.
    """
    def __init__(self, member: Any, connection: BoltConfiguration):
        """Initializes the calculator with the member and connection objects."""
        self.member = member
        self.connection = connection

        # Extract and store properties needed for calculation
        self.Fy = self.member.Fy
        self.loading_condition = getattr(self.member, 'loading_condition', 1)
        self.n_cols = self.connection.n_columns
        self.spacing_col = self.connection.column_spacing
        self.spacing_row = self.connection.row_spacing

        # FIX: Call the method to get the thickness value
        self.t = self._get_member_thickness()

    def _get_member_thickness(self) -> float:
        """Determines thickness from various member types and ensures it has units."""
        if hasattr(self.member, 't'):
            t_val = self.member.t
            return t_val if hasattr(t_val, 'units') else t_val * si.inch
        elif hasattr(self.member, 'tw'):
            return self.member.tw * si.inch
        raise AttributeError("Member does not have a recognizable thickness attribute.")

    @property
    def length_whitmore(self) -> float:
        """Calculates the effective width of the Whitmore section."""
        bolt_group_length = (self.n_cols - 1) * self.spacing_col
        spread_width = 2 * (bolt_group_length * math.tan(math.radians(30)))
        return self.spacing_row + spread_width

    @property
    def area_whitmore(self) -> float:
        """Calculates the area of the Whitmore section."""
        # This hardcoded formula is preserved exactly as you provided.
        return (self.length_whitmore - 4.7 * si.inch) * self.t + 4.7 * si.inch * 0.515 * si.inch

    def calculate_capacity(self, resistance_factor: float = 0.9, debug: bool = False) -> float:
        """
        Calculates the design tensile yield strength of the Whitmore section.
        """
        nominal_capacity = self.Fy * self.area_whitmore
        design_capacity = nominal_capacity * resistance_factor * self.loading_condition

        if debug:
            print("--- DEBUG: Whitmore Section Tensile Yield ---")
            print(f"  Inputs:")
            print(f"    Yield Strength (Fy):         {self.Fy}")
            print(f"    Member Thickness (t):        {self.t:.3f}")
            print(f"  Whitmore Geometry:")
            print(f"    Effective Length (Lw):       {self.length_whitmore:.4f}")
            print(f"    Effective Area (Aw):         {self.area_whitmore:.4f}")
            print(f"  Calculation:")
            print(f"    Nominal Capacity (Rn):       {nominal_capacity:.2f}")
            print(f"    Resistance Factor (φ):       {resistance_factor}")
            print(f"    Loading Condition Multiplier:{self.loading_condition}")
            print(f"    -------------------------------------------")
            print(f"    Final Design Capacity (φRn): {design_capacity:.2f}")

        return design_capacity

class CompressionBucklingCalculator:
    """
    Calculates the compression buckling capacity of a member.
    """
    def __init__(self, member: Any, connection: BoltConfiguration):
        """Initializes the calculator with the member and connection objects."""
        self.member = member
        self.connection = connection
        self.connection_type = self.connection.connection_type
        self.Fy = self.member.Fy
        self.t = self._get_member_thickness

    @property
    def _get_member_thickness(self) -> float:
        """Determines thickness from various member types and ensures it has units."""
        if hasattr(self.member, 't'):
            t_val = self.member.t
            return t_val if hasattr(t_val, 'units') else t_val * si.inch
        elif hasattr(self.member, 'tw'):
            return self.member.tw * si.inch
        raise AttributeError("Member does not have a recognizable thickness attribute.")
    @property
    def k(self) -> float:
      return 0.5 if self.connection_type == "bracing" else 1.2 # for now lets just make a case for common types of connection
    @property
    def r(self):
      return self.t /math.sqrt(12)
    @property
    def slenderness_ratio(self):
      return (self.k*9.76 *si.inch)/(self.r)
    def calculate_capacity(self, resistance_factor = 0.9,debug: bool = False) -> float:
        """
        Calculates the design compression buckling strength of the member.
        """
        if self.slenderness_ratio <= 25:
          return self.Fy * 20.9 *si.inch**2 * resistance_factor
        else:
          raise ValueError("Member is not slender enough for compression buckling calculation.")

class UFMCalculator:
  def __init__(self, beam: Any, support: Any,member: Any, endplate: Any,connection: BoltConfiguration):
    self.beam = beam
    self.support = support
    self.member = member
    self.endplate = endplate
    self.connection = connection
    self.edge_dist = self.connection.edge_distance_vertical
    self.spacing = self.connection.row_spacing
    self.n_rows = self.connection.n_rows
    self.angle = self.connection.angle

  @property
  def beta(self):
    return self.edge_dist  + ((self.n_rows - 1) * self.spacing)/2
  @property
  def eb(self):
    return self.beam.d/2
  @property
  def ec(self):
    return self.support.d/2
  @property
  def alpha(self):
    return (self.eb+self.beta)*math.tan(self.angle) - self.ec
  @property
  def _get_member_thickness_pl(self) -> float:
      """Determines thickness from various member types and ensures it has units."""
      if hasattr(self.endplate, 't'):
          t_val = self.endplate.t
          return t_val if hasattr(t_val, 'units') else t_val * si.inch
      elif hasattr(self.endplate, 'tw'):
          return self.endplate.tw * si.inch
      raise AttributeError("Member does not have a recognizable thickness attribute.")
  @property
  def lh(self):
    return 2*(self.alpha)-2*(self._get_member_thickness_pl)- 3/4 * si.inch

  @property
  def plate_dimension(self):
    return {
    "vertical": round_up_to_interval(self.edge_dist * 2  + ((self.n_rows - 1) * self.spacing) + 0.5 *si.inch,0.25),
    "horizontal": round_up_to_interval(self.lh,0.25),
    "thickness": self._get_member_thickness_pl,
}

tensile_yielding_whitmore = TensileYieldWhitmore(gusset_plate,gusset_connection)

tensile_yielding_whitmore.calculate_capacity(debug=True)

beam = SteelpyMemberFactory.create_steelpy_member(
        section_class=aisc.W_shapes,
        section_name="W21X83",
        material=MATERIALS["a992"],
        shape_type="W"
    )
support = SteelpyMemberFactory.create_steelpy_member(
        section_class=aisc.W_shapes,
        section_name="W14X90",
        material=MATERIALS["a992"],
        shape_type="W"
    )

CompressionBucklingCalculator(gusset_plate,gusset_connection).calculate_capacity(debug=True)

test_UFM = UFMCalculator(beam = beam,support = support,endplate = end_pl_column, member = gusset_plate,connection = gusset_column_endpl_connection)

@dataclass(frozen=True)
class PlateDimensions:
    vertical: float; horizontal: float; thickness: float

@dataclass(frozen=True)
class LoadMultipliers:
    shear_force_column_interface: float; shear_force_beam_interface: float
    normal_force_column: float; normal_force_beam: float

class UFMCalculator:
    """
    Calculates UFM endplate dimensions and load multipliers with a
    comprehensive debug mode to show all intermediate values.
    """
    def __init__(self, beam: Any, support: Any, endplate: Any, connection: Any):
        self._beam_depth = self._get_attribute(beam, ['d', 'depth'])
        self._support_depth = self._get_attribute(support, ['d', 'depth'])
        self._end_plate_thickness = self._get_attribute(endplate, ['t', 'thickness'])
        self._edge_dist = connection.edge_distance_vertical
        self._row_spacing = connection.row_spacing
        self._n_rows = connection.n_rows
        self._angle_rad = connection.angle
        self._debug_header_printed = False

    def _get_attribute(self, obj: Any, potential_names: list[str]) -> float:
        for name in potential_names:
            if hasattr(obj, name):
                value = getattr(obj, name)
                return value if hasattr(value, 'units') else value * si.inch
        raise AttributeError(f"Object does not have any of the expected attributes: {potential_names}")

    def _print_debug_inputs(self):
        """Prints a standard header with all initial inputs, but only once."""
        if not self._debug_header_printed:
            print("--- DEBUG: UFM Calculator Initial Inputs ---")
            print(f"  Beam Depth:              {self._beam_depth:.3f}")
            print(f"  Support Depth:           {self._support_depth:.3f}")
            print(f"  End Plate Thickness:     {self._end_plate_thickness:.3f}")
            print(f"  Edge Distance (vert):    {self._edge_dist:.3f}")
            print(f"  Row Spacing:             {self._row_spacing:.3f}")
            print(f"  Number of Rows:          {self._n_rows}")
            print(f"  Connection Angle:        {math.degrees(self._angle_rad):.2f} degrees")
            self._debug_header_printed = True

    # --- Private Helper Properties for internal calculations ---
    @property
    def _beam_half_depth(self) -> float:
        return self._beam_depth / 2
    @property
    def _support_half_depth(self) -> float:
        return self._support_depth / 2
    @property
    def _beta(self) -> float:
        return self._edge_dist + ((self._n_rows - 1) * self._row_spacing) / 2
    @property
    def _alpha(self) -> float:
        return (self._beam_half_depth + self._beta) * math.tan(self._angle_rad) - self._support_half_depth
    @property
    def _r(self) -> float:
        return (((self._alpha + self._support_half_depth)**2 + (self._beam_half_depth + self._beta)**2))**0.5
    @property
    def _horizontal_plate_length(self) -> float:
        k_line_clearance = 0.75 * si.inch
        return 2 * self._alpha - 2 * self._end_plate_thickness - k_line_clearance

    # --- Public METHODS for final, structured results ---

    def get_dimensions(self, debug: bool = False) -> PlateDimensions:
        """Calculates and returns the final, rounded plate dimensions."""
        if debug:
            self._print_debug_inputs()
            print("\n--- Debugging get_dimensions() ---")
            print(f"  1. Calculate alpha (_alpha):")
            print(f"     _beta = {self._edge_dist:.2f} + (({self._n_rows}-1) * {self._row_spacing:.2f}) / 2 = {self._beta:.4f}")
            print(f"     _alpha = ({self._beam_half_depth:.2f} + {self._beta:.2f}) * tan({math.degrees(self._angle_rad):.1f}°) - {self._support_half_depth:.2f} = {self._alpha:.4f}")
            print(f"  2. Calculate Horizontal Length (lh):")
            print(f"     lh = 2*{self._alpha:.2f} - 2*{self._end_plate_thickness:.2f} - 0.75 = {self._horizontal_plate_length:.4f}")

        unrounded_vertical = self._edge_dist * 2 + ((self._n_rows - 1) * self._row_spacing) + 0.5 * si.inch
        vertical_dim = round_up_to_interval(number=unrounded_vertical, interval=0.25 * si.inch)
        horizontal_dim = round_up_to_interval(number=self._horizontal_plate_length, interval=0.25 * si.inch)

        if debug:
            print(f"  3. Calculate Final Dimensions:")
            print(f"     Vertical (unrounded) = 2*{self._edge_dist:.2f} + (({self._n_rows}-1)*{self._row_spacing:.2f}) + 0.5 = {unrounded_vertical:.4f}")
            print(f"     -> Rounded to 0.25\": {vertical_dim:.2f}")
            print(f"     Horizontal (unrounded) = {self._horizontal_plate_length:.4f}")
            print(f"     -> Rounded to 0.25\": {horizontal_dim:.2f}")

        return PlateDimensions(
            vertical=vertical_dim,
            horizontal=horizontal_dim,
            thickness=self._end_plate_thickness,
        )

    def get_loads_multipliers(self, debug: bool = False) -> LoadMultipliers:
        """Calculates and returns the load multipliers for the UFM interfaces."""
        if debug:
            self._print_debug_inputs()
            print("\n--- Debugging get_loads_multipliers() ---")
            print(f"  1. Calculate geometric properties (_alpha, _beta, _r):")
            print(f"     _beta = {self._edge_dist:.2f} + (({self._n_rows}-1) * {self._row_spacing:.2f}) / 2 = {self._beta:.4f}")
            print(f"     _alpha = ({self._beam_half_depth:.2f} + {self._beta:.2f}) * tan({math.degrees(self._angle_rad):.1f}°) - {self._support_half_depth:.2f} = {self._alpha:.4f}")
            print(f"     _r = sqrt(({self._alpha:.2f} + {self._support_half_depth:.2f})² + ({self._beam_half_depth:.2f} + {self._beta:.2f})²) = {self._r:.4f}")
            print(f"  2. Calculate Final Multipliers:")

        multipliers = LoadMultipliers(
            shear_force_column_interface=self._beta / self._r,
            shear_force_beam_interface=self._beam_half_depth / self._r,
            normal_force_column=self._support_half_depth / self._r,
            normal_force_beam=self._alpha / self._r,
        )

        if debug:
            print(f"     Shear (Column) = _beta / _r = {multipliers.shear_force_column_interface:.4f}")
            print(f"     Shear (Beam)   = beam_half_depth / _r = {multipliers.shear_force_beam_interface:.4f}")
            print(f"     Normal (Column)= support_half_depth / _r = {multipliers.normal_force_column:.4f}")
            print(f"     Normal (Beam)  = _alpha / _r = {multipliers.normal_force_beam:.4f}")

        return multipliers

from logging import debug
ufm_checker = UFMCalculator(
  beam=beam,
  support=support,
  endplate=end_pl_column,
  connection=gusset_column_endpl_connection
)

# --- 3. Get the Final, Structured Result ---
final_dimensions = ufm_checker.get_dimensions(debug=False)
final_multipliers = ufm_checker.get_loads_multipliers(debug=False)

gusset_plate.dimensions = final_dimensions
final_dimensions

class tensile_yielding_1:
  def __init__(self, member: Any, connection: BoltConfiguration):
    self.member = member
    self.connection = connection
    self._thickness = self._get_attribute(self.member, ['t', 'thickness'])
    self.Fy = self.member.Fy
  def get_length(self,interface):
    if interface == "plate horizontal":
        return self.member.dimensions.horizontal - 3/4 * si.inch

    elif interface == "plate vertical":
        return self.member.dimensions.vertical - 3/4 * si.inch

  def _get_attribute(self, obj: Any, potential_names: list[str]) -> float:
    for name in potential_names:
        if hasattr(obj, name):
            value = getattr(obj, name)
            return value if hasattr(value, 'units') else value * si.inch
    raise AttributeError(f"Object does not have any of the expected attributes: {potential_names}")
  def calculate_capacity(self, resistance_factor = 0.9,debug: bool = False,interface = "plate horizontal") -> float:
    """
    Calculates the design tensile yield strength of the
    """
    return self.Fy * self.get_length(interface) * self._thickness * resistance_factor

a = tensile_yielding_1(gusset_plate,gusset_connection)

a.calculate_capacity()

class TensileYieldingCalculator1:
    """
    Calculates design tensile strength based on gross section yielding (AISC J4.1a).
    This calculator expects to be initialized with a member object that has a
    '.dimensions' attribute containing a PlateDimensions object.
    """
    def __init__(self, member: Any):
        """
        Initializes the calculator by extracting required data from the member object.

        Args:
            member: The member object to be checked. It must contain a '.dimensions'
                    attribute with the gross dimensions.
        """
        # --- Data Extraction (The "Adapter" Step) ---
        if not hasattr(member, 'dimensions'):
            raise AttributeError("The provided 'member' object must have a '.dimensions' attribute.")

        self.dimensions: PlateDimensions = member.dimensions
        self.Fy = member.Fy
        self.loading_condition = getattr(member, 'loading_condition', 1)
        self._thickness = self.dimensions.thickness

    def _calculate_capacity_for_path(
        self,
        gross_length: float,
        interface_name: str,
        resistance_factor: float,
        debug: bool
    ) -> float:
        """A private helper to perform the core calculation, avoiding code duplication."""
        effective_length = gross_length - 0.75 * si.inch
        gross_area = effective_length * self._thickness
        nominal_capacity = self.Fy * gross_area
        design_capacity = nominal_capacity * resistance_factor * self.loading_condition

        if debug:
            print(f"\n--- DEBUG: Tensile Yielding ({interface_name}) ---")
            print(f"  Inputs:")
            print(f"    Yield Strength (Fy):     {self.Fy}")
            print(f"    Gross Length:            {gross_length:.2f}")
            print(f"    Thickness:               {self._thickness:.3f}")
            print(f"  Calculation:")
            print(f"    Effective Length:        {effective_length:.2f} (Gross Length - 0.75\")")
            print(f"    Gross Area (Ag):         {gross_area:.4f}")
            print(f"    Nominal Capacity (Pn):   {nominal_capacity:.2f}")
            print(f"    Resistance Factor (φ):   {resistance_factor}")
            print(f"    Loading Condition:       {self.loading_condition}")
            print(f"  -------------------------------------------")
            print(f"  Final Design Capacity (φPn): {design_capacity:.2f}")

        return design_capacity

    def calculate_capacity_horizontal(self, resistance_factor: float = 0.9, debug: bool = False) -> float:
        """Calculates the design tensile yield strength along the HORIZONTAL path."""
        return self._calculate_capacity_for_path(
            gross_length=self.dimensions.horizontal,
            interface_name="Horizontal",
            resistance_factor=resistance_factor,
            debug=debug
        )

    def calculate_capacity_vertical(self, resistance_factor: float = 0.9, debug: bool = False) -> float:
        """Calculates the design tensile yield strength along the VERTICAL path."""
        return self._calculate_capacity_for_path(
            gross_length=self.dimensions.vertical,
            interface_name="Vertical",
            resistance_factor=resistance_factor,
            debug=debug
        )

a = TensileYieldingCalculator1(gusset_plate)

a.calculate_capacity_horizontal(debug = True)

a.calculate_capacity_vertical(debug = True)

from typing import Dict, Optional, Type, Any, Literal
@dataclass(frozen=True)
class WeldElectrode:
    """
    Represents the properties of a weld electrode. It's frozen because
    these are standard, immutable values.
    """
    Fexx: float  # Nominal strength of the weld electrode (e.g., 70 ksi for E70XX)

# Define a type-safe literal for different weld types
WeldType = Literal["fillet", "groove"]

WELD_ELECTRODES: Dict[str, WeldElectrode] = {
    "e60xx": WeldElectrode(Fexx=60.0 * si.ksi),
    "e70xx": WeldElectrode(Fexx=70.0 * si.ksi),
    "e80xx": WeldElectrode(Fexx=80.0 * si.ksi),
}
@dataclass
class WeldConfiguration:
    """
    Defines the geometry and properties of a specific weld line in a connection.
    """
    weld_size: float
    length: float
    electrode: WeldElectrode  # Link to the WeldElectrode object
    weld_type: WeldType = "fillet" # Default to fillet, the most common type

class WebLocalYieldingCalculator:
    """
    Calculates the web local yielding capacity based on AISC Specification J10.2,
    with a clear separation between input and calculation debugging.
    """
    def __init__(self, member: Any, connection: Any):
        """Initializes the calculator by extracting all necessary primitive values."""
        # Standardize all data extraction through the private helper method
        self._Fy = member.Fy
        self._tw = self._get_attribute(member, ['tw'])
        self._k = self._get_attribute(member, ['k', 'k_det'])
        self._d = self._get_attribute(member, ['d', 'depth'])
        self._connection_length = connection.length
        self._loading_condition = getattr(member, 'loading_condition', 1)

    def _get_attribute(self, obj: Any, potential_names: list[str]) -> float:
        """Safely gets a numeric attribute from an object and ensures it has units."""
        for name in potential_names:
            if hasattr(obj, name):
                value = getattr(obj, name)
                return value if hasattr(value, 'units') else value * si.inch
        raise AttributeError(f"Object does not have any of the expected attributes: {potential_names}")

    def _print_debug_inputs(self, thickness_pl: float):
        """A private helper to print a clean block of all initial input values."""
        print("--- DEBUG: Web Local Yielding Inputs ---")
        print(f"  Yield Strength (Fy):        {self._Fy}")
        print(f"  Web Thickness (tw):         {self._tw:.3f}")
        print(f"  Detailing Distance (k):     {self._k:.3f}")
        print(f"  Member Depth (d):           {self._d:.2f}")
        print(f"  Connection Length (lb):     {self._connection_length:.2f}")
        print(f"  End Plate Thickness (tpl):  {thickness_pl:.3f}")

    def _print_debug_calculation(self, centroid, multiplier, bearing_len, Pn, phiRn, phi):
        """A private helper to print the detailed step-by-step calculation."""
        print("\n--- DEBUG: Calculation Steps ---")
        print(f"  1. Calculate Connection Load Centroid:")
        # Acknowledge the hardcoded value in the debug output
        print(f"     Centroid = lb/2 + clip + tpl = {self._connection_length/2:.2f} + 0.75\" + {centroid - self._connection_length/2 - 0.75*si.inch:.2f} = {centroid:.2f}")
        print(f"  2. Determine Multiplier:")
        print(f"     Condition: Is load centroid ({centroid:.2f}) <= member depth ({self._d:.2f})?")
        print(f"     Result: {centroid <= self._d}, therefore multiplier = {multiplier}")
        print(f"  3. Calculate Bearing Length:")
        print(f"     Bearing Length = {multiplier}*k + lb = ({multiplier}*{self._k:.2f}) + {self._connection_length:.2f} = {bearing_len:.2f}")
        print(f"  4. Calculate Nominal Capacity (Pn):")
        print(f"     Pn = Fy * tw * Bearing Length = {self._Fy} * {self._tw:.3f} * {bearing_len:.2f} = {Pn:.2f}")
        print(f"  5. Calculate Design Capacity (φRn):")
        print(f"     φRn = Pn * φ * loading_condition = {Pn:.2f} * {phi} * {self._loading_condition} = {phiRn:.2f}")

    def calculate_capacity(self, thickness_pl: float, resistance_factor: float = 1.0, debug: bool = False) -> float:
        """
        Calculates the design web local yielding strength (φRn).

        Args:
            thickness_pl: The thickness of the connecting plate (e.g., end plate).
            resistance_factor: The resistance factor (φ) for this limit state.
            debug: If True, prints a detailed breakdown of the calculation.
        """
        if debug:
            self._print_debug_inputs(thickness_pl)

        # Per your new logic, calculate the load centroid
        # Acknowledging the hardcoded clip distance as a placeholder for future improvement.
        clip_dist = 3/4 * si.inch
        connection_load_centroid = self._connection_length / 2 + clip_dist + thickness_pl

        if connection_load_centroid <= self._d:
            multiplier_k = 2.5
        else:
            multiplier_k = 5.0

        bearing_length = (multiplier_k * self._k) + self._connection_length
        nominal_capacity = self._Fy * self._tw * bearing_length
        design_capacity = nominal_capacity * resistance_factor * self._loading_condition

        if debug:
            self._print_debug_calculation(
                connection_load_centroid, multiplier_k, bearing_length, nominal_capacity, design_capacity, resistance_factor
            )

        return design_capacity

class web

selected_electrode = WELD_ELECTRODES["e70xx"]

# --- 2. Define the Weld Configuration using the new dataclass ---
# This creates a structured, type-safe object representing a specific weld.
gusset_weld = WeldConfiguration(
    weld_size=0.3125 * si.inch,  # 5/16" fillet weld
    length=31.50 * si.inch,
    electrode=selected_electrode  # Assign the electrode object directly
)

a= WebLocalYieldingCalculator(beam,gusset_weld)

a.calculate_capacity(debug = True,thickness_pl = 0.75 * si.inch)



a = 1 * si.inch

a

(32.25-3/4)/2 + 0.75*2

(32.25-0.75)/2 + 0.75 + 0.75

